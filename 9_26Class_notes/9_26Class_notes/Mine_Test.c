#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
/* 一.
1. 判断大小端问题：
1.大端：低地址存储高数据  2.小端：第地址存储低数据


int main(){
	int ret = IsLittle();
	if (ret == 0){
		printf("小端存储\n");
	}
	else{
		printf("大端存储\n");
	}
	return 0;
}
   大小端判断方法1：
    int IsLittle(){
	int a = 0x11223344;//赋值为16进制数
	char *pc = (char *)&a; //其含义为用char*类型的指针指向int类型的变量 需要把该变量地址强转为char*类型
	if (*pc == 0x44){
		return 0;    //char类型为一个字节即8位  若后八位==0x44 则满足第地址存放低数据即小端
	}
	return 1;    //否则为大端
						   
}


  大小端判断方法2：
union Un      //union 联合体关键字  其中内容共用一块内存  即该代码中a ch公用一块内存
{
	int a;     //由于int为4个字节 即32位  ch 1个字节 8位  所以整个联合体为32位
	char ch;
};


    int IsLittle(){
	union Un uu;
	uu.a = 0x11223344; 
	if (uu.ch == 0x44){  //由于a ch共用同一块内存 如果 char== 0x44 ；即为小端 
		return 0; 
	}
	return 1;
}
*/

/*  二.
   1.char  signed char(有符号char)  unsigned char(无符号char) 在内存中的存储  
   2.负数在内存中以其补码的形式存储
    
int main(){  //该代码中 所有的char类型都由%d打印输出 而变量均为1个字节 8位的char类型 所以需要整型提升
	char a = -1;
	//-1原码：1000 0001
	//  反码：1111 1110
	//  补码：1111 1111
	//整形提升：1111 .....1111 1111 1111  
	//提升以后由于是负数所以为补码 需要转化为原码才能推算出%d情况下输出什么数字
	//  反码： 1111 ......1111 1111 1110
	//  原码： 1000 ......0000 0000 0001;  所以结果为-1
    signed char b = -1;
	//与char同理 所以结果依然为-1
	unsigned char c = -1;
	//原码：10000000000000000000000000000001
	//反码：11111111111111111111111111111110
	//补码：11111111111111111111111111111111
	//因为赋值给char : 11111111
   // 由于是无符号char：整形提升以后为：0000 ......0000 1111 1111；//所以输出结果为255
	printf("a=%d,b=%d,c=%d", a, b, c);
	return 0;
}
*/

/* 三.
  1.%u 为无符号整型打印

int main(){
	char ch = -128;
	//-128原码：1000 ......0000 1000 0000
	//    反码：1111 ......1111 0111 1111
	//    补码：1111 ......1111 1000 0000
	//赋值给char 所以取 1000 0000
	//使用%u识别打印 需要整型提升：1111 ......1111 1000 0000  
	//%u为整型无符号打印 所以此时即为原码 打印结果为 1111 ......1111 1000 0000 的十进制数字
	printf("%u\n", ch);
	return 0;
}
*/

/* 四.
  1.关于char的取值范围为-127 ――128 的理解：
  max：由于char在内存中为8位  且最高位为符号位 所以：
     +128 =  1000 0000  由于最高位为符号位 即为0  所以由此可知不在char的范围内
   而+127 =  0111 1111  可以存储 所以最大值位+127

   min：-128 = 1 1000 0000 由于char只有8位 所以符号为1无法识别 
       而负数在内存中用补码存储： 
	  1 1000 0000 反码为：1 0111 1111
	              补码为：1 1000 0000 由于char只有8位 所以符号为1无法识别 所以内存中-128的存储实际上
				  看起来和-0一样
  关于-127 ―― 128之间的循环 类似于圈一样的解释：
      -127 + （-1） 在内存中的运算：  1000 0000                //-1在内存中当然也是以其补码的形式存储
	                                + 1111 1111  结果为1 0111 1111 使用十进制输出即为127形成了
									                               -127――128之间的循环即所谓的“圈”

*/  
